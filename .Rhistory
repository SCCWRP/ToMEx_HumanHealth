charge, #positive or negatibe
zetapotential,# numeric
invitro.invivo) %>%
#max.size.ingest.mm,#max ingestible size
#acute.chronic_f,
# dose.mg.L.master.AF.noec,
#dose.particles.mL.master.AF.noec,
#effect.score) %>%  #1 = minor, 2 = photosynthesis, feeding, 3 = growth, chlorophyll content, 4 = reproduction, 5  = population growth, 6 = survival
filter(!size_f == "Not Reported") %>%   #take out not reported
mutate_if(is.character, as.factor) %>%
mutate(effect_10 = case_when(
effect == "Yes" ~ 1,
effect == "No" ~ 0)) %>%
filter(!size_f == "Not Reported")  #take out not reported
#recode variables
multiVar <- multiVar %>% mutate(effect_10 = case_when(
effect == "Y" ~ 1,
effect == "N" ~ 0
))# %>%
#mutate_all(is.character, ~as.factor())
#inspect
skim(multiVar)
# subset data to selected variables
require(tidyverse)
multiVar <- human_setup %>% dplyr::select(#doi, size.category,
size_f,
size.length.um.used.for.conversion,
shape,
polymer,
particle.volume.um,
density.mg.um3,
bio.org, #biological level of organization
#af.time, #assessment factor based on exposure time
effect, #yes no
exposure.duration.d,
exposure.route, #Factor
media.temp, #numeric
lvl1_f, #endpoints
lvl2_f, #endpoints
# lvl3,
dose.mg.mL.master,
sex, #factor
#media.ph, #numeric
dose.particles.L.master,
dose.mg.kg.day.bw.nominal,
# dose.particles.kg.bw.nominal,
#effect.metric, #NOEC LOEC
functional.group, #factor
charge, #positive or negatibe
zetapotential,# numeric
invitro.invivo) %>%
#max.size.ingest.mm,#max ingestible size
#acute.chronic_f,
# dose.mg.L.master.AF.noec,
#dose.particles.mL.master.AF.noec,
#effect.score) %>%  #1 = minor, 2 = photosynthesis, feeding, 3 = growth, chlorophyll content, 4 = reproduction, 5  = population growth, 6 = survival
filter(!size_f == "Not Reported") %>%   #take out not reported
mutate_if(is.character, as.factor) %>%
mutate(effect_10 = case_when(
effect == "Yes" ~ 1,
effect == "No" ~ 0)) %>%
filter(!size_f == "Not Reported")  #take out not reported
#recode variables
multiVar <- multiVar %>% mutate(effect_10 = case_when(
effect == "Y" ~ 1,
effect == "N" ~ 0
))# %>%
#mutate_all(is.character, ~as.factor())
#inspect
skim(multiVar)
## Estimate an OLS Regression
fitols <- lm(effect_10 ~ size.length.um.used.for.conversion + dose.particles.L.master + dose.mg.mL.master  + exposure.duration.d  + bio.org + particle.volume.um + shape + polymer + exposure.route + lvl1_f + invitro.invivo + density.mg.um3,
na.action = na.omit,
data = multiVar)
summary(fitols)
step.model <- stepAIC(fitols, direction = "both", trace = FALSE)
summary(step.model)
require(reshape2)
multiVar %>%
dplyr::select(size.length.um.used.for.conversions, particle.volume.um3, exposure.duration.d ,media.temp, dose.particles.mL.master) %>%
melt() %>%  #convert wide to long
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
ggplot(aes(x = value)) +
stat_density() +
facet_wrap(~variable, scales = "free")
require(reshape2)
multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d ,media.temp, dose.particles.L.master, dose.mg.mL.master) %>%
melt() %>%  #convert wide to long
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
ggplot(aes(x = value)) +
stat_density() +
facet_wrap(~variable, scales = "free")
require(reshape2)
multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, dose.particles.L.master, dose.mg.mL.master) %>%
melt() %>%  #convert wide to long
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
ggplot(aes(x = value)) +
stat_density() +
facet_wrap(~variable, scales = "free")
require(reshape2)
multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master) %>%
melt() %>%  #convert wide to long
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
ggplot(aes(x = value)) +
stat_density() +
facet_wrap(~variable, scales = "free")
multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master) %>%
melt() %>%  #convert wide to long
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
ggplot(aes(x = value)) +
stat_density() +
facet_wrap(~variable, scales = "free")
require(uwot)
require(Rtsne)
require(vizier) #devtools::install_github("jlmelville/vizier")
# For some functions we need to strip out non-numeric columns and convert data to matrix
x2m <- function(X) {
if (!methods::is(X, "matrix")) {
m <- as.matrix(X[, which(vapply(X, is.numeric, logical(1)))])
}
else {m <- X}
m}
#choose values with most completeness
multiVar2 <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() #drop missing
#convert discrete variables to numeric
multiVar2[] <- data.matrix(multiVar2)
# build umap for small dataset (<10,000 points)
multiVar_map  <- umap(multiVar2, pca = 10)
# build umap for small dataset (<10,000 points)
multiVar_map  <- umap(multiVar2, pca = 5)
# build umap for small dataset (<10,000 points)
multiVar_map  <- umap(multiVar2, pca = 5)
#visualize umap
embed_img <- function(X, Y, k = 15, ...) {
args <- list(...)
args$coords <- Y
args$x <- X
do.call(vizier::embed_plot, args)
}
#plot
embed_img(multiVar2, multiVar_map, pc_axes = TRUE, equal_axes = TRUE, alpha_scale = 0.5, title = "Tox UMAP", cex = 1)
#plot
embed_img(multiVar2, multiVar_map, pc_axes = TRUE, equal_axes = TRUE, alpha_scale = 0.5, title = "Human Tox UMAP", cex = 1)
embed_img(multiVar2, multiVar_map, pc_axes = TRUE, equal_axes = TRUE, alpha_scale = 0.5, title = "Human Tox UMAP", cex = 1)
multiVar2
#PCA
pca <- stats::prcomp(multiVar2, retx = TRUE, rank. = 2)
#build color pallete
my_colors = colorRampPalette(c("red", "yellow", "green"))(nrow(multiVar2))
#plot
embed_plot(pca$x, multiVar2$polymer, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#choose values with most completeness
multiVar2 <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() #drop missing
multiVar2
#choose values with most completeness
multiVar2 <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() #drop missing
multiVar2
#choose values with most completeness
multiVar2 <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() #drop missing
#PCA
pca <- stats::prcomp(multiVar2, retx = TRUE, rank. = 2)
multiVar2
multiVar2[,-7, -8]
multiVar2[,-7:8]
multiVar2[,1:6]
#PCA
pca <- stats::prcomp(multiVar2[,1:6], retx = TRUE, rank. = 2)
#build color pallete
my_colors = colorRampPalette(c("red", "yellow", "green"))(nrow(multiVar2))
#plot
embed_plot(pca$x, multiVar2$polymer, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#PCA
pca <- stats::prcomp(multiVar2[,1:6], retx = TRUE, rank. = 3)
#build color pallete
my_colors = colorRampPalette(c("red", "yellow", "green"))(nrow(multiVar2))
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#PCA
pca <- stats::prcomp(multiVar2[,1:6], retx = FALSE, rank. = 2)
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = TRUE)
#PCA
pca <- stats::prcomp(multiVar2[,1:6], retx = TRUE, rank. = 2)
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.5, equal_axes = FALSE)
#plot
embed_plot(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"), #turbo, #rainbow, #my_colors,
title = "Polymer PCA", alpha_scale = 0.2, equal_axes = FALSE)
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", subtitle = "mammalian", alpha_scale = 0.5, equal_axes = TRUE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", sub = "mammalian", alpha_scale = 0.5, equal_axes = TRUE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", alpha_scale = 0.5, equal_axes = TRUE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, #color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", alpha_scale = 0.5, equal_axes = TRUE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, #color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", alpha_scale = 0.5, equal_axes = FALSE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, #color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", alpha_scale = 0.2, equal_axes = FALSE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
require(plotly)
embed_plotly(pca$x, multiVar2$invitro.invivo, #color_scheme = palette.colors(palette = "Okabe-Ito"),
title = "in Vitro/ in Vivo PCA", alpha_scale = 0.1, equal_axes = FALSE,
tooltip = paste("Study Type:", multiVar2$invitro.invivo))
#trim data so effect is always known
multiVar_sub <- multiVar2 %>%
drop_na(effect_10)
#trim data so effect is always known
multiVar_sub <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo, effect_10) %>%
drop_na()
#trim data so effect is always known
multiVar_sub <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo, effect_10) %>%
drop_na()
# Split data into training and test sets
set.seed(42)
multiVar_sub[,"train"] <- ifelse(runif(nrow(multiVar_sub)) < 0.8, 1, 0)
# Separate trainig and test sets
trainSet <- multiVar_sub[multiVar_sub$train==1,]
testSet <- multiVar_sub[multiVar_sub$train==0,]
#get column index of train flag
trainColNum <- grep("train", names(trainSet))
# Remove train flag column from train and test sets
trainSet <- trainSet[, -trainColNum]
testSet <- testSet[, -trainColNum]
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect_10 ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 20, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
#trim data so effect is always known
multiVar_sub <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo, effect_10) %>%
drop_na()
# Split data into training and test sets
set.seed(42)
multiVar_sub[,"train"] <- ifelse(runif(nrow(multiVar_sub)) < 0.8, 1, 0)
# Separate trainig and test sets
trainSet <- multiVar_sub[multiVar_sub$train==1,]
testSet <- multiVar_sub[multiVar_sub$train==0,]
#get column index of train flag
trainColNum <- grep("train", names(trainSet))
# Remove train flag column from train and test sets
trainSet <- trainSet[, -trainColNum]
testSet <- testSet[, -trainColNum]
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect_10 ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 20, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
trainSet$dose.particles.L.master
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect_10 ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo
method = "class", #classification because response is discrete
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect_10 ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 20, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
trainSet
#trim data so effect is always known
multiVar_sub <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo, effect) %>% # effect_10, effect) %>%
drop_na()
# Split data into training and test sets
set.seed(42)
multiVar_sub[,"train"] <- ifelse(runif(nrow(multiVar_sub)) < 0.8, 1, 0)
# Separate trainig and test sets
trainSet <- multiVar_sub[multiVar_sub$train==1,]
testSet <- multiVar_sub[multiVar_sub$train==0,]
#get column index of train flag
trainColNum <- grep("train", names(trainSet))
# Remove train flag column from train and test sets
trainSet <- trainSet[, -trainColNum]
testSet <- testSet[, -trainColNum]
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 20, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3,
#dose.particles.L.master,
dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 20, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
trainSet
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
rpart(effect ~ size.length.um.used.for.conversion,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3,dose.particles.L.master,
dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
skim(trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
#trim data so effect is always known
multiVar_sub <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo, effect) %>% # effect_10, effect) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na()
# Split data into training and test sets
set.seed(42)
multiVar_sub[,"train"] <- ifelse(runif(nrow(multiVar_sub)) < 0.8, 1, 0)
# Separate trainig and test sets
trainSet <- multiVar_sub[multiVar_sub$train==1,]
testSet <- multiVar_sub[multiVar_sub$train==0,]
#get column index of train flag
trainColNum <- grep("train", names(trainSet))
# Remove train flag column from train and test sets
trainSet <- trainSet[, -trainColNum]
testSet <- testSet[, -trainColNum]
# Split data into training and test sets
set.seed(42)
multiVar_sub[,"train"] <- ifelse(runif(nrow(multiVar_sub)) < 0.8, 1, 0)
# Separate trainig and test sets
trainSet <- multiVar_sub[multiVar_sub$train==1,]
testSet <- multiVar_sub[multiVar_sub$train==0,]
#get column index of train flag
trainColNum <- grep("train", names(trainSet))
# Remove train flag column from train and test sets
trainSet <- trainSet[, -trainColNum]
testSet <- testSet[, -trainColNum]
#get column index of predicted variable in dataset
typeColNum <- grep("effect",names(multiVar_sub))
#build tree
require(rpart)
set.seed(15097)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, particle.volume.um, exposure.duration.d, density.mg.um3, dose.particles.L.master, dose.mg.mL.master, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
rpart(effect ~ dose.particles.L.master, data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, #particle.volume.um, exposure.duration.d, density.mg.um3, , polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
print(t1, digits=4)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, particle.volume.um, exposure.duration.d, density.mg.um3, , polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, particle.volume.um, exposure.duration.d, density.mg.um3, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, particle.volume.um, #exposure.duration.d, density.mg.um3, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master,particle.volume.um, #exposure.duration.d, density.mg.um3, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, particle.volume.um, #exposure.duration.d, density.mg.um3, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
t1 <- rpart(effect ~ size.length.um.used.for.conversion, dose.particles.L.master, dose.mg.mL.master, #particle.volume.um, exposure.duration.d, density.mg.um3, polymer, invitro.invivo,
method = "class", #classification because response is discrete
control = rpart.control(minbucket = 10, cp=0.008), #requires that there be at least 19 cases (responded + nonrespondents) in the final grouping of variable values of the terminal node of the tre..
data = trainSet)
print(t1, digits=4)
require(rpart.plot)
cols <- ifelse(t1$frame$yval == 1, "gray50", "black")
prp(t1, main="Tree for Effect",
extra=106, # display prob of survival and percent of obs
nn=TRUE, # display node numbers
fallen.leaves=TRUE, # put leaves on the bottom of page
branch=.5, # change angle of branch lines
faclen=0, # do not abbreviate factor levels
trace=1, # print automatically calculated cex
shadow.col="gray", # shadows under the leaves
branch.lty=1, # draw branches using solid lines
branch.type=5, # branch lines width = weight(frame$wt), no. of cases here
split.cex=1.2, # make split text larger than node text
split.prefix="is ", # put "is " before split text
split.suffix="?", # put "?" after split text
col=cols, border.col=cols, # cols[2] if survived
split.box.col="lightgray", # lightgray split boxes (default is white)
split.border.col="darkgray", # darkgray border on split boxes
split.round=0.5) # round the split box corners a tad
require(party)
crf <- cforest(effect ~ size.length.um.used.for.conversion + dose.particles.L.master+ dose.mg.mL.master+ particle.volume.um+ exposure.duration.d+ density.mg.um3+ polymer+ invitro.invivo,
controls = cforest_control(ntree = 500,
mincriterion = qnorm(0.8),
trace = TRUE), # adds project bar because it's very slow
data = trainSet)
crf
fitted <- predict(crf, testSet, OOB = TRUE, type ="response")
misClasificError <- mean(fitted != testSet$effect)
print(paste('Training Accuracy', 1 - misClasificError))
misClasificError <- mean(fitted != testSet$effect)
misClasificError <- mean(fitted != as.numeric(testSet$effect))
fitted
fitted <- as.numeric(predict(crf, testSet, OOB = TRUE, type ="response"))
misClasificError <- mean(fitted != as.numeric(testSet$effect))
print(paste('Training Accuracy', 1 - misClasificError))
mean(fitted != as.numeric(testSet$effect))
print(paste('Training Accuracy', 1 - misClasificError))
print(crf)
#Obtaining predicted probabilites for Test data
tree.probs=predict(crf,
newdata = testSet,
type="prob")
library(quantregForest)
library(caret)
library(tidyverse)
library(tidymodels)
library(skimr)
library(sf)
library(ggspatial)
library(nhdplusTools)
library(patchwork)
library(Metrics)
library(gt)
multiVar
skim(multiVar)
#choose relevant predictors and log-transform
multiVar_small_log <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion + dose.particles.L.master+ dose.mg.mL.master+ particle.volume.um+ exposure.duration.d+ density.mg.um3+ polymer+ invitro.invivo, effect) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() %>%  #drop missing
mutate(effect_10 = case_when( #convert ordinal to numeric
effect_f == "Yes" ~ 1,
effect_f == "No" ~ 0
))# %>%
multiVar$size.length.um.used.for.conversion
#choose relevant predictors and log-transform
multiVar_small_log <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion)
#choose relevant predictors and log-transform
multiVar_small_log <- multiVar %>%
dplyr::select(size.length.um.used.for.conversion + dose.particles.L.master+ dose.mg.mL.master+ particle.volume.um+ exposure.duration.d+ density.mg.um3+ polymer+ invitro.invivo, effect) %>%
mutate_if(~is.numeric(.) && (.) > 0, log10) %>%
drop_na() %>%  #drop missing
mutate(effect_10 = case_when( #convert ordinal to numeric
effect_f == "Yes" ~ 1,
effect_f == "No" ~ 0
))# %>%
